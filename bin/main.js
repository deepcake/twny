// Generated by Haxe 4.3.4
(function ($global) { "use strict";
class Main {
	static main() {
		let canvas = window.document.querySelector("#canvas");
		let w;
		let h;
		let resize = function() {
			w = canvas.width = window.innerWidth;
			h = canvas.height = window.innerHeight;
		};
		window.addEventListener("resize",resize);
		resize();
		let context = canvas.getContext("2d",null);
		context.font = "50px serif";
		context.imageSmoothingEnabled = true;
		let emoji1 = ["🌲","🌳"];
		let emoji2 = ["🌱","🌷","🌾","🌼","🌻"];
		let emoji3 = ["🐒","🦌","🦘"];
		let sprites = [];
		let _g = 0;
		while(_g < 200) {
			++_g;
			let index = Std.random(emoji1.length);
			let scale = 1.5 + 0.5 * Math.random();
			sprites.push({ x : Math.random() * w, y : Math.random() * h, sx : scale, sy : scale, img : emoji1[index]});
		}
		let _g1 = 0;
		while(_g1 < 500) {
			++_g1;
			let index = Std.random(emoji2.length);
			let scale = 0.75 + 0.25 * Math.random();
			sprites.push({ x : Math.random() * w, y : Math.random() * h, sx : scale, sy : scale, img : emoji2[index]});
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < 100) {
			++_g3;
			_g2.push({ x : Math.random() * w, y : Math.random() * h, sx : 1, sy : 1, img : emoji3[Std.random(emoji3.length)]});
		}
		sprites = sprites.concat(_g2);
		sprites.sort(function(s1,s2) {
			return s1.y - s2.y | 0;
		});
		let _g4 = 0;
		while(_g4 < _g2.length) {
			let s = _g2[_g4];
			++_g4;
			twny_TweenerTools.get_instance().tween(2,true).then(twny_TweenerTools.get_instance().tween(.25,true).transition(new twny_internal_FixedToTransition(twny_easing_Quint.easeOut,function() {
				return s.sx;
			},.75,function(v) {
				s.sx = v;
			})).transition(new twny_internal_FixedToTransition(twny_easing_Quint.easeOut,function() {
				return s.sy;
			},1.5,function(v) {
				s.sy = v;
			}))).then(twny_TweenerTools.get_instance().tween(1,true).transition(new twny_internal_RelativeTransition(twny_easing_Linear.easeNone,function() {
				return s.x;
			},function() {
				return s.x + 150;
			},function(v) {
				s.x = v;
			})).then(twny_TweenerTools.get_instance().tween(.25,true).transition(new twny_internal_FixedToTransition(twny_easing_Quint.easeOut,function() {
				return s.sx;
			},1,function(v) {
				s.sx = v;
			})).transition(new twny_internal_FixedToTransition(twny_easing_Quint.easeOut,function() {
				return s.sy;
			},1,function(v) {
				s.sy = v;
			}))).onComplete(function() {
				if(s.x > w) {
					s.x -= w;
				}
			})).then(twny_TweenerTools.get_instance().tween(.5,true).transition(new twny_internal_RelativeTransition(twny_easing_Cubic.easeOut,function() {
				return s.y;
			},function() {
				return s.y - 100;
			},function(v) {
				s.y = v;
			})).then(twny_TweenerTools.get_instance().tween(.5,true).transition(new twny_internal_RelativeTransition(twny_easing_Cubic.easeIn,function() {
				return s.y;
			},function() {
				return s.y + 100;
			},function(v) {
				s.y = v;
			})))).start(Math.random()).repeat();
		}
		let update = function() {
			twny_TweenerTools.get_instance().update(0.06);
			context.setTransform(1,0,0,1,0,0);
			context.clearRect(0,0,w,h);
			let _g = 0;
			while(_g < sprites.length) {
				let s = sprites[_g];
				++_g;
				context.setTransform(1,0,0,1,0,0);
				context.translate(s.x,s.y);
				context.scale(-s.sx,s.sy);
				context.fillText(s.img,0,0);
			}
		};
		window.setInterval(update,60);
	}
}
class Std {
	static random(x) {
		if(x <= 0) {
			return 0;
		} else {
			return Math.floor(Math.random() * x);
		}
	}
}
class haxe_ds_ArraySort {
	static sort(a,cmp) {
		haxe_ds_ArraySort.rec(a,cmp,0,a.length);
	}
	static rec(a,cmp,from,to) {
		let middle = from + to >> 1;
		if(to - from < 12) {
			if(to <= from) {
				return;
			}
			let _g = from + 1;
			while(_g < to) {
				let j = _g++;
				while(j > from) {
					if(cmp(a[j],a[j - 1]) < 0) {
						haxe_ds_ArraySort.swap(a,j - 1,j);
					} else {
						break;
					}
					--j;
				}
			}
			return;
		}
		haxe_ds_ArraySort.rec(a,cmp,from,middle);
		haxe_ds_ArraySort.rec(a,cmp,middle,to);
		haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
	}
	static doMerge(a,cmp,from,pivot,to,len1,len2) {
		while(true) {
			let first_cut;
			let second_cut;
			let len11;
			let len22;
			if(len1 == 0 || len2 == 0) {
				return;
			}
			if(len1 + len2 == 2) {
				if(cmp(a[pivot],a[from]) < 0) {
					haxe_ds_ArraySort.swap(a,pivot,from);
				}
				return;
			}
			if(len1 > len2) {
				len11 = len1 >> 1;
				first_cut = from + len11;
				second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
				len22 = second_cut - pivot;
			} else {
				len22 = len2 >> 1;
				second_cut = pivot + len22;
				first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
				len11 = first_cut - from;
			}
			haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
			let new_mid = first_cut + len22;
			haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
			from = new_mid;
			pivot = second_cut;
			len1 -= len11;
			len2 -= len22;
		}
	}
	static rotate(a,cmp,from,mid,to) {
		if(from == mid || mid == to) {
			return;
		}
		let n = haxe_ds_ArraySort.gcd(to - from,mid - from);
		while(n-- != 0) {
			let val = a[from + n];
			let shift = mid - from;
			let p1 = from + n;
			let p2 = from + n + shift;
			while(p2 != from + n) {
				a[p1] = a[p2];
				p1 = p2;
				if(to - p2 > shift) {
					p2 += shift;
				} else {
					p2 = from + (shift - (to - p2));
				}
			}
			a[p1] = val;
		}
	}
	static gcd(m,n) {
		while(n != 0) {
			let t = m % n;
			m = n;
			n = t;
		}
		return m;
	}
	static upper(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[val],a[mid]) < 0) {
				len = half;
			} else {
				from = mid + 1;
				len = len - half - 1;
			}
		}
		return from;
	}
	static lower(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[mid],a[val]) < 0) {
				from = mid + 1;
				len = len - half - 1;
			} else {
				len = half;
			}
		}
		return from;
	}
	static swap(a,i,j) {
		let tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
class twny__$Tween_Cb {
	constructor(time,fn) {
		this.time = time;
		this.fn = fn;
	}
}
class twny_Tween {
	constructor(runner,duration,autodispose) {
		if(autodispose == null) {
			autodispose = true;
		}
		this.cbIndex = 0;
		this.stocked = false;
		this.transitions = [];
		this.autodispose = true;
		this.repeatable = false;
		this.paused = false;
		this.running = false;
		this.elapsed = 0.0;
		this.runner = runner != null ? runner : twny_TweenerTools.get_instance();
		this.duration = duration;
		this.set_autodispose(autodispose);
		this.backwardDuration = duration;
	}
	repeat() {
		this.set_repeatable(true);
		return this;
	}
	update(dt) {
		if(dt >= 0 && this.running && !this.get_paused()) {
			this.elapsed += dt;
			let k = this.elapsed < this.duration ? this.elapsed / this.duration : 1.0;
			let _g = 0;
			let _g1 = this.transitions;
			while(_g < _g1.length) _g1[_g++].apply(k);
			this.emit();
			if(this.elapsed >= this.duration) {
				let offset = this.elapsed - this.duration;
				this.running = false;
				if(this.next != null) {
					let _g = 0;
					let _g1 = this.next;
					while(_g < _g1.length) _g1[_g++].setup(offset);
				} else if(this.head != null) {
					if(this.head.get_fullyCompleted()) {
						if(this.get_repeatable()) {
							let last = this.head.tail();
							this.head.setup(last.elapsed - last.duration);
						} else if(this.get_autodispose()) {
							this.head.dispose();
						}
					}
				} else if(this.get_repeatable()) {
					this.setup(offset);
				} else if(this.get_autodispose()) {
					this.dispose();
				}
			}
		}
	}
	start(offset) {
		if(offset == null) {
			offset = 0.;
		}
		this.setup(offset);
		return this;
	}
	dispose() {
		if(this.next != null) {
			let _g = 0;
			let _g1 = this.next;
			while(_g < _g1.length) _g1[_g++].dispose();
		}
		let _g = 0;
		let _g1 = this.transitions;
		while(_g < _g1.length) _g1[_g++].dispose();
		this.transitions.length = 0;
		this.head = null;
		this.prev = null;
		this.next = null;
		this.callbacks = null;
		this.cbIndex = 0;
		this.elapsed = 0.0;
		this.running = false;
	}
	onComplete(cb) {
		let time = this.duration;
		if(this.callbacks == null) {
			this.callbacks = [new twny__$Tween_Cb(time,cb)];
		} else {
			this.callbacks.push(new twny__$Tween_Cb(time,cb));
			haxe_ds_ArraySort.sort(this.callbacks,function(cb1,cb2) {
				if(cb1.time == cb2.time) {
					return 0;
				} else if(cb1.time > cb2.time) {
					return 1;
				} else {
					return -1;
				}
			});
		}
		return this;
	}
	then(tween) {
		tween.attachTo(this);
		if(this.next == null) {
			this.next = [];
		}
		this.next.push(tween);
		return this;
	}
	transition(t) {
		this.transitions.push(t);
		return this;
	}
	attachTo(tween) {
		this.prev = tween;
		let tmp = tween != null ? tween.head : null;
		this.head = tmp != null ? tmp : tween;
		this.backwardDuration = this.prev.backwardDuration + this.duration;
		this.elapsed = 0.0;
		this.running = false;
		if(this.next != null) {
			let _g = 0;
			let _g1 = this.next;
			while(_g < _g1.length) _g1[_g++].attachTo(this);
		}
	}
	emit() {
		if(this.callbacks != null) {
			let _g = this.cbIndex;
			let _g1 = this.callbacks.length;
			while(_g < _g1) {
				let i = _g++;
				if(this.elapsed >= this.callbacks[i].time) {
					this.callbacks[i].fn();
					this.cbIndex++;
				} else {
					break;
				}
			}
		}
	}
	setup(offset) {
		if(offset == null) {
			offset = 0.;
		}
		this.stock();
		this.elapsed = 0.0;
		this.running = true;
		this.cbIndex = 0;
		this.emit();
		let _g = 0;
		let _g1 = this.transitions;
		while(_g < _g1.length) _g1[_g++].setup();
		this.update(offset);
	}
	stock() {
		if(!this.stocked) {
			this.runner.updating.push(this);
			this.stocked = true;
		}
	}
	unstock() {
		this.stocked = false;
	}
	tail() {
		let ret = this;
		if(this.next != null) {
			if(this.next.length == 1) {
				ret = this.next[0].tail();
			} else {
				let max = 0.;
				let _g = 0;
				let _g1 = this.next;
				while(_g < _g1.length) {
					let t = _g1[_g++].tail();
					let d = t.backwardDuration;
					if(d > max) {
						max = d;
						ret = t;
					}
				}
			}
		}
		return ret;
	}
	get_paused() {
		if(this.head != null) {
			return this.head.get_paused();
		} else {
			return this.paused;
		}
	}
	get_repeatable() {
		if(this.head != null) {
			return this.head.get_repeatable();
		} else {
			return this.repeatable;
		}
	}
	set_repeatable(value) {
		if(this.head != null) {
			return this.head.set_repeatable(value);
		} else {
			return this.repeatable = value;
		}
	}
	get_autodispose() {
		if(this.head != null) {
			return this.head.get_autodispose();
		} else {
			return this.autodispose;
		}
	}
	set_autodispose(value) {
		if(this.head != null) {
			return this.head.set_autodispose(value);
		} else {
			return this.autodispose = value;
		}
	}
	get_fullyCompleted() {
		let ret = this.elapsed >= this.duration;
		if(this.next != null) {
			if(this.next.length == 1) {
				ret = ret && this.next[0].get_fullyCompleted();
			} else {
				let _g = 0;
				let _g1 = this.next;
				while(_g < _g1.length) {
					let n = _g1[_g++];
					ret = ret && n.get_fullyCompleted();
				}
			}
		}
		return ret;
	}
}
class twny_Tweener {
	constructor() {
		this.updating = [];
	}
	tween(duration,autodispose) {
		if(autodispose == null) {
			autodispose = true;
		}
		return new twny_Tween(this,duration,autodispose);
	}
	update(dt) {
		let l = this.updating.length;
		let i = 0;
		while(i < l) {
			let tween = this.updating[i];
			tween.update(dt);
			if(!tween.running) {
				tween.unstock();
				this.updating.splice(i,1);
				--l;
			} else {
				++i;
			}
		}
	}
}
class twny_TweenerTools {
	static get_instance() {
		if(twny_TweenerTools.instance == null) {
			twny_TweenerTools.instance = new twny_Tweener();
		}
		return twny_TweenerTools.instance;
	}
}
class twny_easing_Cubic {
	static easeIn(ratio) {
		return ratio * ratio * ratio;
	}
	static easeOut(ratio) {
		return --ratio * ratio * ratio + 1;
	}
}
class twny_easing_Linear {
	static easeNone(ratio) {
		return ratio;
	}
}
class twny_easing_Quint {
	static easeOut(k) {
		return --k * k * k * k * k + 1;
	}
}
class twny_internal_Transition {
	apply(k) {
		let value = k < 1.0 ? this.from + (this.to - this.from) * this.easing(k) : this.to;
		this.set(value);
	}
}
class twny_internal_FixedToTransition extends twny_internal_Transition {
	constructor(easing,getf,to,set) {
		super();
		this.easing = easing;
		this.getf = getf;
		this.to = to;
		this.set = set;
	}
	setup() {
		this.from = this.getf();
	}
	dispose() {
		this.easing = null;
		this.getf = null;
		this.set = null;
	}
}
class twny_internal_RelativeTransition extends twny_internal_Transition {
	constructor(easing,getf,gett,set) {
		super();
		this.easing = easing;
		this.getf = getf;
		this.gett = gett;
		this.set = set;
	}
	setup() {
		this.from = this.getf();
		this.to = this.gett();
	}
	dispose() {
		this.easing = null;
		this.getf = null;
		this.gett = null;
		this.set = null;
	}
}
{
}
Main.main();
})({});
